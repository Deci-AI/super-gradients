<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>super_gradients.training.losses.yolox_loss &mdash; SuperGradients 3.0.3 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> SuperGradients
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Welcome To SuperGradients</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html">Version 3 is out! Notebooks have been updated!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#build-with-supergradients">Build with SuperGradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#quick-installation">Quick Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#what-s-new">What’s New</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#coming-soon">Coming soon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#table-of-content">Table of Content</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#getting-started">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#advanced-features">Advanced Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#installation-methods">Installation Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#implemented-model-architectures">Implemented Model Architectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#documentation">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#contributing">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#citation">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#community">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#license">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../welcome.html#deci-platform">Deci Platform</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Technical Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../super_gradients.common.html">Common package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../super_gradients.training.html">Training package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">SuperGradients</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>super_gradients.training.losses.yolox_loss</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for super_gradients.training.losses.yolox_loss</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Based on https://github.com/Megvii-BaseDetection/YOLOX (Apache-2.0 license)</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.distributed</span> <span class="k">as</span> <span class="nn">dist</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torch.nn.modules.loss</span> <span class="kn">import</span> <span class="n">_Loss</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>

<span class="kn">from</span> <span class="nn">super_gradients.common.abstractions.abstract_logger</span> <span class="kn">import</span> <span class="n">get_logger</span>
<span class="kn">from</span> <span class="nn">super_gradients.training.utils</span> <span class="kn">import</span> <span class="n">torch_version_is_greater_or_equal</span>
<span class="kn">from</span> <span class="nn">super_gradients.training.utils.detection_utils</span> <span class="kn">import</span> <span class="n">calculate_bbox_iou_matrix</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IOUloss</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IoU loss with the following supported loss types:</span>
<span class="sd">    Attributes:</span>
<span class="sd">        reduction: str: One of [&quot;mean&quot;, &quot;sum&quot;, &quot;none&quot;] reduction to apply to the computed loss (Default=&quot;none&quot;)</span>
<span class="sd">        loss_type: str: One of [&quot;iou&quot;, &quot;giou&quot;] where:</span>
<span class="sd">            * &#39;iou&#39; for</span>
<span class="sd">                (1 - iou^2)</span>
<span class="sd">            * &#39;giou&#39; according to &quot;Generalized Intersection over Union: A Metric and A Loss for Bounding Box Regression&quot;</span>
<span class="sd">                (1 - giou), where giou = iou - (cover_box - union_box)/cover_box</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">loss_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;iou&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IOUloss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_args</span><span class="p">(</span><span class="n">loss_type</span><span class="p">,</span> <span class="n">reduction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span> <span class="o">=</span> <span class="n">reduction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss_type</span> <span class="o">=</span> <span class="n">loss_type</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_args</span><span class="p">(</span><span class="n">loss_type</span><span class="p">,</span> <span class="n">reduction</span><span class="p">):</span>
        <span class="n">supported_losses</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;iou&quot;</span><span class="p">,</span> <span class="s2">&quot;giou&quot;</span><span class="p">]</span>
        <span class="n">supported_reductions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">loss_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_losses</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Illegal loss_type value: &quot;</span> <span class="o">+</span> <span class="n">loss_type</span> <span class="o">+</span> <span class="s2">&quot;, expected one of: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">supported_losses</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">reduction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_reductions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Illegal reduction value: &quot;</span> <span class="o">+</span> <span class="n">reduction</span> <span class="o">+</span> <span class="s2">&quot;, expected one of: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">supported_reductions</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">pred</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">tl</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">pred</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pred</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">target</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">br</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">pred</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pred</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">target</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">target</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">area_p</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">pred</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">area_g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">target</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">en</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">&lt;</span> <span class="n">br</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">tl</span><span class="o">.</span><span class="n">type</span><span class="p">())</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">area_i</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">br</span> <span class="o">-</span> <span class="n">tl</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">en</span>
        <span class="n">area_u</span> <span class="o">=</span> <span class="n">area_p</span> <span class="o">+</span> <span class="n">area_g</span> <span class="o">-</span> <span class="n">area_i</span>
        <span class="n">iou</span> <span class="o">=</span> <span class="p">(</span><span class="n">area_i</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">area_u</span> <span class="o">+</span> <span class="mf">1e-16</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_type</span> <span class="o">==</span> <span class="s2">&quot;iou&quot;</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">iou</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_type</span> <span class="o">==</span> <span class="s2">&quot;giou&quot;</span><span class="p">:</span>
            <span class="n">c_tl</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">pred</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pred</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">target</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">c_br</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">pred</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pred</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">target</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">target</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">area_c</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">c_br</span> <span class="o">-</span> <span class="n">c_tl</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">giou</span> <span class="o">=</span> <span class="n">iou</span> <span class="o">-</span> <span class="p">(</span><span class="n">area_c</span> <span class="o">-</span> <span class="n">area_u</span><span class="p">)</span> <span class="o">/</span> <span class="n">area_c</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mf">1e-16</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">giou</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">loss</span>


<div class="viewcode-block" id="YoloXDetectionLoss"><a class="viewcode-back" href="../../../../super_gradients.training.html#super_gradients.training.losses.YoloXDetectionLoss">[docs]</a><span class="k">class</span> <span class="nc">YoloXDetectionLoss</span><span class="p">(</span><span class="n">_Loss</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate YOLOX loss:</span>
<span class="sd">    L = L_objectivness + L_iou + L_classification + 1[use_l1]*L_l1</span>

<span class="sd">    where:</span>
<span class="sd">        * L_iou, L_classification and L_l1 are calculated only between cells and targets that suit them;</span>
<span class="sd">        * L_objectivness is calculated for all cells.</span>

<span class="sd">        L_classification:</span>
<span class="sd">            for cells that have suitable ground truths in their grid locations add BCEs</span>
<span class="sd">            to force a prediction of IoU with a GT in a multi-label way</span>
<span class="sd">            Coef: 1.</span>
<span class="sd">        L_iou:</span>
<span class="sd">            for cells that have suitable ground truths in their grid locations</span>
<span class="sd">            add (1 - IoU^2), IoU between a predicted box and each GT box, force maximum IoU</span>
<span class="sd">            Coef: 5.</span>
<span class="sd">        L_l1:</span>
<span class="sd">            for cells that have suitable ground truths in their grid locations</span>
<span class="sd">            l1 distance between the logits and GTs in “logits” format (the inverse of “logits to predictions” ops)</span>
<span class="sd">            Coef: 1[use_l1]</span>
<span class="sd">        L_objectness:</span>
<span class="sd">            for each cell add BCE with a label of 1 if there is GT assigned to the cell</span>
<span class="sd">            Coef: 1</span>

<span class="sd">    Attributes:</span>
<span class="sd">        strides: list: List of Yolo levels output grid sizes (i.e [8, 16, 32]).</span>
<span class="sd">        num_classes: int: Number of classes.</span>
<span class="sd">        use_l1: bool: Controls the L_l1 Coef as discussed above (default=False).</span>
<span class="sd">        center_sampling_radius: float: Sampling radius used for center sampling when creating the fg mask (default=2.5).</span>
<span class="sd">        iou_type: str: Iou loss type, one of [&quot;iou&quot;,&quot;giou&quot;] (deafult=&quot;iou&quot;).</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strides</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_l1</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">center_sampling_radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">iou_type</span><span class="o">=</span><span class="s2">&quot;iou&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strides</span> <span class="o">=</span> <span class="n">strides</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">num_classes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">center_sampling_radius</span> <span class="o">=</span> <span class="n">center_sampling_radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_l1</span> <span class="o">=</span> <span class="n">use_l1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l1_loss</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">L1Loss</span><span class="p">(</span><span class="n">reduction</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bcewithlog_loss</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BCEWithLogitsLoss</span><span class="p">(</span><span class="n">reduction</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iou_loss</span> <span class="o">=</span> <span class="n">IOUloss</span><span class="p">(</span><span class="n">reduction</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">loss_type</span><span class="o">=</span><span class="n">iou_type</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">component_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Component names for logging during training.</span>
<span class="sd">        These correspond to 2nd item in the tuple returned in self.forward(...).</span>
<span class="sd">        See super_gradients.Trainer.train() docs for more info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;iou&quot;</span><span class="p">,</span> <span class="s2">&quot;obj&quot;</span><span class="p">,</span> <span class="s2">&quot;cls&quot;</span><span class="p">,</span> <span class="s2">&quot;l1&quot;</span><span class="p">,</span> <span class="s2">&quot;num_fg&quot;</span><span class="p">,</span> <span class="s2">&quot;Loss&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="YoloXDetectionLoss.forward"><a class="viewcode-back" href="../../../../super_gradients.training.html#super_gradients.training.losses.YoloXDetectionLoss.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">List</span><span class="p">]],</span> <span class="n">targets</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param model_output: Union[list, Tuple[torch.Tensor, List]]:</span>
<span class="sd">             When list-</span>
<span class="sd">              output from all Yolo levels, each of shape [Batch x 1 x GridSizeY x GridSizeX x (4 + 1 + Num_classes)]</span>
<span class="sd">             And when tuple- the second item is the described list (first item is discarded)</span>

<span class="sd">        :param targets: torch.Tensor: Num_targets x (4 + 2)], values on dim 1 are: image id in a batch, class, box x y w h</span>

<span class="sd">        :return: loss, all losses separately in a detached tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_output</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># in test/eval mode the Yolo model outputs a tuple where the second item is the raw predictions</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">predictions</span> <span class="o">=</span> <span class="n">model_output</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">model_output</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_loss</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_make_grid</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a tensor of xy coordinates of size (1,1,nx,ny,2)</span>

<span class="sd">        :param nx: int: cells along x axis (default=20)</span>
<span class="sd">        :param ny: int: cells along the y axis (default=20)</span>
<span class="sd">        :return: torch.tensor of xy coordinates of size (1,1,nx,ny,2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">torch_version_is_greater_or_equal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
            <span class="c1"># https://github.com/pytorch/pytorch/issues/50276</span>
            <span class="n">yv</span><span class="p">,</span> <span class="n">xv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">)],</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yv</span><span class="p">,</span> <span class="n">xv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_compute_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">targets</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param predictions:     output from all Yolo levels, each of shape</span>
<span class="sd">                                [Batch x 1 x GridSizeY x GridSizeX x (4 + 1 + Num_classes)]</span>
<span class="sd">        :param targets:         [Num_targets x (4 + 2)], values on dim 1 are: image id in a batch, class, box x y w h</span>

<span class="sd">        :return:                loss, all losses separately in a detached tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">expanded_strides</span><span class="p">,</span> <span class="n">transformed_outputs</span><span class="p">,</span> <span class="n">raw_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_predictions</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>

        <span class="n">bbox_preds</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>  <span class="c1"># [batch, n_anchors_all, 4]</span>
        <span class="n">obj_preds</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>  <span class="c1"># [batch, n_anchors_all, 1]</span>
        <span class="n">cls_preds</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">5</span><span class="p">:]</span>  <span class="c1"># [batch, n_anchors_all, n_cls]</span>

        <span class="c1"># calculate targets</span>
        <span class="n">total_num_anchors</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cls_targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">reg_targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">l1_targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj_targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fg_masks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">num_fg</span><span class="p">,</span> <span class="n">num_gts</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">image_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">transformed_outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">labels_im</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="n">targets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">image_idx</span><span class="p">]</span>
            <span class="n">num_gt</span> <span class="o">=</span> <span class="n">labels_im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">num_gts</span> <span class="o">+=</span> <span class="n">num_gt</span>
            <span class="k">if</span> <span class="n">num_gt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cls_target</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">new_zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="p">))</span>
                <span class="n">reg_target</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">new_zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">l1_target</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">new_zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">obj_target</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">new_zeros</span><span class="p">((</span><span class="n">total_num_anchors</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">fg_mask</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">new_zeros</span><span class="p">(</span><span class="n">total_num_anchors</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># GT boxes to image coordinates</span>
                <span class="n">gt_bboxes_per_image</span> <span class="o">=</span> <span class="n">labels_im</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="n">gt_classes</span> <span class="o">=</span> <span class="n">labels_im</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">bboxes_preds_per_image</span> <span class="o">=</span> <span class="n">bbox_preds</span><span class="p">[</span><span class="n">image_idx</span><span class="p">]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># assign cells to ground truths, at most one GT per cell</span>
                    <span class="n">gt_matched_classes</span><span class="p">,</span> <span class="n">fg_mask</span><span class="p">,</span> <span class="n">pred_ious_this_matching</span><span class="p">,</span> <span class="n">matched_gt_inds</span><span class="p">,</span> <span class="n">num_fg_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_assignments</span><span class="p">(</span>
                        <span class="n">image_idx</span><span class="p">,</span>
                        <span class="n">num_gt</span><span class="p">,</span>
                        <span class="n">total_num_anchors</span><span class="p">,</span>
                        <span class="n">gt_bboxes_per_image</span><span class="p">,</span>
                        <span class="n">gt_classes</span><span class="p">,</span>
                        <span class="n">bboxes_preds_per_image</span><span class="p">,</span>
                        <span class="n">expanded_strides</span><span class="p">,</span>
                        <span class="n">x_shifts</span><span class="p">,</span>
                        <span class="n">y_shifts</span><span class="p">,</span>
                        <span class="n">cls_preds</span><span class="p">,</span>
                        <span class="n">obj_preds</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># TODO: CHECK IF ERROR IS CUDA OUT OF MEMORY</span>
                <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;OOM RuntimeError is raised due to the huge memory cost during label assignment. </span><span class="se">\</span>
<span class="s2">                                   CPU mode is applied in this batch. If you want to avoid this issue, </span><span class="se">\</span>
<span class="s2">                                   try to reduce the batch size or image size.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">empty_cache</span><span class="p">()</span>
                    <span class="n">gt_matched_classes</span><span class="p">,</span> <span class="n">fg_mask</span><span class="p">,</span> <span class="n">pred_ious_this_matching</span><span class="p">,</span> <span class="n">matched_gt_inds</span><span class="p">,</span> <span class="n">num_fg_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_assignments</span><span class="p">(</span>
                        <span class="n">image_idx</span><span class="p">,</span>
                        <span class="n">num_gt</span><span class="p">,</span>
                        <span class="n">total_num_anchors</span><span class="p">,</span>
                        <span class="n">gt_bboxes_per_image</span><span class="p">,</span>
                        <span class="n">gt_classes</span><span class="p">,</span>
                        <span class="n">bboxes_preds_per_image</span><span class="p">,</span>
                        <span class="n">expanded_strides</span><span class="p">,</span>
                        <span class="n">x_shifts</span><span class="p">,</span>
                        <span class="n">y_shifts</span><span class="p">,</span>
                        <span class="n">cls_preds</span><span class="p">,</span>
                        <span class="n">obj_preds</span><span class="p">,</span>
                        <span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">empty_cache</span><span class="p">()</span>
                <span class="n">num_fg</span> <span class="o">+=</span> <span class="n">num_fg_img</span>

                <span class="n">cls_target</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">gt_matched_classes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="p">)</span> <span class="o">*</span> <span class="n">pred_ious_this_matching</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">obj_target</span> <span class="o">=</span> <span class="n">fg_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">reg_target</span> <span class="o">=</span> <span class="n">gt_bboxes_per_image</span><span class="p">[</span><span class="n">matched_gt_inds</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_l1</span><span class="p">:</span>
                    <span class="n">l1_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_l1_target</span><span class="p">(</span>
                        <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">new_zeros</span><span class="p">((</span><span class="n">num_fg_img</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span>
                        <span class="n">gt_bboxes_per_image</span><span class="p">[</span><span class="n">matched_gt_inds</span><span class="p">],</span>
                        <span class="n">expanded_strides</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">fg_mask</span><span class="p">],</span>
                        <span class="n">x_shifts</span><span class="o">=</span><span class="n">x_shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">fg_mask</span><span class="p">],</span>
                        <span class="n">y_shifts</span><span class="o">=</span><span class="n">y_shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">fg_mask</span><span class="p">],</span>
                    <span class="p">)</span>

            <span class="c1"># collect targets for all loss terms over the whole batch</span>
            <span class="n">cls_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls_target</span><span class="p">)</span>
            <span class="n">reg_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg_target</span><span class="p">)</span>
            <span class="n">obj_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_target</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">transformed_outputs</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="n">fg_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fg_mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_l1</span><span class="p">:</span>
                <span class="n">l1_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l1_target</span><span class="p">)</span>

        <span class="c1"># concat all targets over the batch (get rid of batch dim)</span>
        <span class="n">cls_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">cls_targets</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">reg_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">reg_targets</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">obj_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">obj_targets</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">fg_masks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">fg_masks</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_l1</span><span class="p">:</span>
            <span class="n">l1_targets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">l1_targets</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">num_fg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_fg</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># loss terms divided by the total number of foregrounds</span>
        <span class="n">loss_iou</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iou_loss</span><span class="p">(</span><span class="n">bbox_preds</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)[</span><span class="n">fg_masks</span><span class="p">],</span> <span class="n">reg_targets</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">num_fg</span>
        <span class="n">loss_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcewithlog_loss</span><span class="p">(</span><span class="n">obj_preds</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">obj_targets</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">num_fg</span>
        <span class="n">loss_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcewithlog_loss</span><span class="p">(</span><span class="n">cls_preds</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="p">)[</span><span class="n">fg_masks</span><span class="p">],</span> <span class="n">cls_targets</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">num_fg</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_l1</span><span class="p">:</span>
            <span class="n">loss_l1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l1_loss</span><span class="p">(</span><span class="n">raw_outputs</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)[</span><span class="n">fg_masks</span><span class="p">],</span> <span class="n">l1_targets</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">num_fg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss_l1</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">reg_weight</span> <span class="o">=</span> <span class="mf">5.0</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">reg_weight</span> <span class="o">*</span> <span class="n">loss_iou</span> <span class="o">+</span> <span class="n">loss_obj</span> <span class="o">+</span> <span class="n">loss_cls</span> <span class="o">+</span> <span class="n">loss_l1</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">loss</span><span class="p">,</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">loss_iou</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">loss_obj</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">loss_cls</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">loss_l1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">device</span><span class="p">),</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">num_fg</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_gts</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">device</span><span class="p">),</span>
                    <span class="n">loss</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
        <span class="p">)</span>

<div class="viewcode-block" id="YoloXDetectionLoss.prepare_predictions"><a class="viewcode-back" href="../../../../super_gradients.training.html#super_gradients.training.losses.YoloXDetectionLoss.prepare_predictions">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert raw outputs of the network into a format that merges outputs from all levels</span>
<span class="sd">        :param predictions:     output from all Yolo levels, each of shape</span>
<span class="sd">                                [Batch x 1 x GridSizeY x GridSizeX x (4 + 1 + Num_classes)]</span>
<span class="sd">        :return:    5 tensors representing predictions:</span>
<span class="sd">                        * x_shifts: shape [1 x * num_cells x 1],</span>
<span class="sd">                          where num_cells = grid1X * grid1Y + grid2X * grid2Y + grid3X * grid3Y,</span>
<span class="sd">                          x coordinate on the grid cell the prediction is coming from</span>
<span class="sd">                        * y_shifts: shape [1 x  num_cells x 1],</span>
<span class="sd">                          y coordinate on the grid cell the prediction is coming from</span>
<span class="sd">                        * expanded_strides: shape [1 x num_cells x 1],</span>
<span class="sd">                          stride of the output grid the prediction is coming from</span>
<span class="sd">                        * transformed_outputs: shape [batch_size x num_cells x (num_classes + 5)],</span>
<span class="sd">                          predictions with boxes in real coordinates and logprobabilities</span>
<span class="sd">                        * raw_outputs: shape [batch_size x num_cells x (num_classes + 5)],</span>
<span class="sd">                          raw predictions with boxes and confidences as logits</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raw_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">transformed_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x_shifts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y_shifts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">expanded_strides</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">):</span>
            <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_anchors</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">num_outputs</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># IN FIRST PASS CREATE GRIDS ACCORDING TO OUTPUT SHAPE (BATCH,1,IMAGE_H/STRIDE,IMAGE_2/STRIDE,NUM_CLASSES+5)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grids</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_grid</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">type_as</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

            <span class="c1"># e.g. [batch_size, 1, 28, 28, 85] -&gt; [batch_size, 784, 85]</span>
            <span class="n">output_raveled</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_anchors</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">)</span>
            <span class="c1"># e.g [1, 784, 2]</span>
            <span class="n">grid_raveled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_anchors</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_l1</span><span class="p">:</span>
                <span class="c1"># e.g [1, 784, 4]</span>
                <span class="n">raw_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_raveled</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>

            <span class="c1"># box logits to coordinates</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">output_raveled</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid_raveled</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">wh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">output_raveled</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">classes</span> <span class="o">=</span> <span class="n">output_raveled</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">:]</span>
            <span class="n">output_raveled</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">centers</span><span class="p">,</span> <span class="n">wh</span><span class="p">,</span> <span class="n">classes</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># outputs with boxes in real coordinates, probs as logits</span>
            <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_raveled</span><span class="p">)</span>
            <span class="c1"># x cell coordinates of all 784 predictions, 0, 0, 0, ..., 1, 1, 1, ...</span>
            <span class="n">x_shifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grid_raveled</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="c1"># y cell coordinates of all 784 predictions, 0, 1, 2, ..., 0, 1, 2, ...</span>
            <span class="n">y_shifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grid_raveled</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># e.g. [1, 784, stride of this level (one of [8, 16, 32])]</span>
            <span class="n">expanded_strides</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">grid_raveled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">type_as</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>

        <span class="c1"># all 4 below have shapes of [batch_size , num_cells, num_values_pre_cell]</span>
        <span class="c1"># where num_anchors * num_cells is e.g. 1 * (28 * 28 + 14 * 14 + 17 * 17)</span>
        <span class="n">transformed_outputs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">transformed_outputs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x_shifts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">x_shifts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y_shifts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">y_shifts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">expanded_strides</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">expanded_strides</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_l1</span><span class="p">:</span>
            <span class="n">raw_outputs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">raw_outputs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">expanded_strides</span><span class="p">,</span> <span class="n">transformed_outputs</span><span class="p">,</span> <span class="n">raw_outputs</span></div>

<div class="viewcode-block" id="YoloXDetectionLoss.get_l1_target"><a class="viewcode-back" href="../../../../super_gradients.training.html#super_gradients.training.losses.YoloXDetectionLoss.get_l1_target">[docs]</a>    <span class="k">def</span> <span class="nf">get_l1_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1_target</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param l1_target:   tensor of zeros of shape [Num_cell_gt_pairs x 4]</span>
<span class="sd">        :param gt:          targets in coordinates [Num_cell_gt_pairs x (4 + 1 + num_classes)]</span>

<span class="sd">        :return:            targets in the format corresponding to logits</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l1_target</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gt</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">stride</span> <span class="o">-</span> <span class="n">x_shifts</span>
        <span class="n">l1_target</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gt</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">stride</span> <span class="o">-</span> <span class="n">y_shifts</span>
        <span class="n">l1_target</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gt</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">stride</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">l1_target</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gt</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">stride</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l1_target</span></div>

<div class="viewcode-block" id="YoloXDetectionLoss.get_assignments"><a class="viewcode-back" href="../../../../super_gradients.training.html#super_gradients.training.losses.YoloXDetectionLoss.get_assignments">[docs]</a>    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">get_assignments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image_idx</span><span class="p">,</span>
        <span class="n">num_gt</span><span class="p">,</span>
        <span class="n">total_num_anchors</span><span class="p">,</span>
        <span class="n">gt_bboxes_per_image</span><span class="p">,</span>
        <span class="n">gt_classes</span><span class="p">,</span>
        <span class="n">bboxes_preds_per_image</span><span class="p">,</span>
        <span class="n">expanded_strides</span><span class="p">,</span>
        <span class="n">x_shifts</span><span class="p">,</span>
        <span class="n">y_shifts</span><span class="p">,</span>
        <span class="n">cls_preds</span><span class="p">,</span>
        <span class="n">obj_preds</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;gpu&quot;</span><span class="p">,</span>
        <span class="n">ious_loss_cost_coeff</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
        <span class="n">outside_boxes_and_center_cost_coeff</span><span class="o">=</span><span class="mf">100000.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Match cells to ground truth:</span>
<span class="sd">            * at most 1 GT per cell</span>
<span class="sd">            * dynamic number of cells per GT</span>

<span class="sd">        :param outside_boxes_and_center_cost_coeff: float: Cost coefficiant of cells the radius and bbox of gts in dynamic</span>
<span class="sd">         matching (default=100000).</span>
<span class="sd">        :param ious_loss_cost_coeff: float: Cost coefficiant for iou loss in dynamic matching (default=3).</span>
<span class="sd">        :param image_idx: int: Image index in batch.</span>
<span class="sd">        :param num_gt: int: Number of ground trunth targets in the image.</span>
<span class="sd">        :param total_num_anchors: int: Total number of possible bboxes = sum of all grid cells.</span>
<span class="sd">        :param gt_bboxes_per_image: torch.Tensor: Tensor of gt bboxes for  the image, shape: (num_gt, 4).</span>
<span class="sd">        :param gt_classes: torch.Tesnor: Tensor of the classes in the image, shape: (num_preds,4).</span>
<span class="sd">        :param bboxes_preds_per_image: Tensor of the classes in the image, shape: (num_preds).</span>
<span class="sd">        :param expanded_strides: torch.Tensor: Stride of the output grid the prediction is coming from,</span>
<span class="sd">            shape (1 x num_cells x 1).</span>
<span class="sd">        :param x_shifts: torch.Tensor: X&#39;s in cell coordinates, shape (1,num_cells,1).</span>
<span class="sd">        :param y_shifts: torch.Tensor: Y&#39;s in cell coordinates, shape (1,num_cells,1).</span>
<span class="sd">        :param cls_preds: torch.Tensor: Class predictions in all cells, shape (batch_size, num_cells).</span>
<span class="sd">        :param obj_preds: torch.Tensor: Objectness predictions in all cells, shape (batch_size, num_cells).</span>
<span class="sd">        :param mode: str: One of [&quot;gpu&quot;,&quot;cpu&quot;], Controls the device the assignment operation should be taken place on (deafult=&quot;gpu&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;cpu&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;------------CPU Mode for This Batch-------------&quot;</span><span class="p">)</span>
            <span class="n">gt_bboxes_per_image</span> <span class="o">=</span> <span class="n">gt_bboxes_per_image</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="n">bboxes_preds_per_image</span> <span class="o">=</span> <span class="n">bboxes_preds_per_image</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="n">gt_classes</span> <span class="o">=</span> <span class="n">gt_classes</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="n">expanded_strides</span> <span class="o">=</span> <span class="n">expanded_strides</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="n">x_shifts</span> <span class="o">=</span> <span class="n">x_shifts</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">y_shifts</span> <span class="o">=</span> <span class="n">y_shifts</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

        <span class="c1"># create a mask for foreground cells</span>
        <span class="n">fg_mask</span><span class="p">,</span> <span class="n">is_in_boxes_and_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_in_boxes_info</span><span class="p">(</span><span class="n">gt_bboxes_per_image</span><span class="p">,</span> <span class="n">expanded_strides</span><span class="p">,</span> <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">total_num_anchors</span><span class="p">,</span> <span class="n">num_gt</span><span class="p">)</span>

        <span class="n">bboxes_preds_per_image</span> <span class="o">=</span> <span class="n">bboxes_preds_per_image</span><span class="p">[</span><span class="n">fg_mask</span><span class="p">]</span>
        <span class="n">cls_preds_</span> <span class="o">=</span> <span class="n">cls_preds</span><span class="p">[</span><span class="n">image_idx</span><span class="p">][</span><span class="n">fg_mask</span><span class="p">]</span>
        <span class="n">obj_preds_</span> <span class="o">=</span> <span class="n">obj_preds</span><span class="p">[</span><span class="n">image_idx</span><span class="p">][</span><span class="n">fg_mask</span><span class="p">]</span>
        <span class="n">num_in_boxes_anchor</span> <span class="o">=</span> <span class="n">bboxes_preds_per_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;cpu&quot;</span><span class="p">:</span>
            <span class="n">gt_bboxes_per_image</span> <span class="o">=</span> <span class="n">gt_bboxes_per_image</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">bboxes_preds_per_image</span> <span class="o">=</span> <span class="n">bboxes_preds_per_image</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

        <span class="c1"># calculate cost between all foregrounds and all ground truths (used only for matching)</span>
        <span class="n">pair_wise_ious</span> <span class="o">=</span> <span class="n">calculate_bbox_iou_matrix</span><span class="p">(</span><span class="n">gt_bboxes_per_image</span><span class="p">,</span> <span class="n">bboxes_preds_per_image</span><span class="p">,</span> <span class="n">x1y1x2y2</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">gt_cls_per_image</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">gt_classes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="p">)</span>
        <span class="n">gt_cls_per_image</span> <span class="o">=</span> <span class="n">gt_cls_per_image</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_in_boxes_anchor</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pair_wise_ious_loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pair_wise_ious</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;cpu&quot;</span><span class="p">:</span>
            <span class="n">cls_preds_</span><span class="p">,</span> <span class="n">obj_preds_</span> <span class="o">=</span> <span class="n">cls_preds_</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">obj_preds_</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">autocast</span><span class="p">(</span><span class="n">enabled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">cls_preds_</span> <span class="o">=</span> <span class="n">cls_preds_</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_gt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sigmoid_</span><span class="p">()</span> <span class="o">*</span> <span class="n">obj_preds_</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_gt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sigmoid_</span><span class="p">()</span>
            <span class="n">pair_wise_cls_loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">binary_cross_entropy</span><span class="p">(</span><span class="n">cls_preds_</span><span class="o">.</span><span class="n">sqrt_</span><span class="p">(),</span> <span class="n">gt_cls_per_image</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">cls_preds_</span>

        <span class="n">cost</span> <span class="o">=</span> <span class="n">pair_wise_cls_loss</span> <span class="o">+</span> <span class="n">ious_loss_cost_coeff</span> <span class="o">*</span> <span class="n">pair_wise_ious_loss</span> <span class="o">+</span> <span class="n">outside_boxes_and_center_cost_coeff</span> <span class="o">*</span> <span class="p">(</span><span class="o">~</span><span class="n">is_in_boxes_and_center</span><span class="p">)</span>

        <span class="c1"># further filter foregrounds: create pairs between cells and ground truth, based on cost and IoUs</span>
        <span class="n">num_fg</span><span class="p">,</span> <span class="n">gt_matched_classes</span><span class="p">,</span> <span class="n">pred_ious_this_matching</span><span class="p">,</span> <span class="n">matched_gt_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_k_matching</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">pair_wise_ious</span><span class="p">,</span> <span class="n">gt_classes</span><span class="p">,</span> <span class="n">num_gt</span><span class="p">,</span> <span class="n">fg_mask</span><span class="p">)</span>
        <span class="c1"># discard tensors related to cost</span>
        <span class="k">del</span> <span class="n">pair_wise_cls_loss</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">pair_wise_ious</span><span class="p">,</span> <span class="n">pair_wise_ious_loss</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;cpu&quot;</span><span class="p">:</span>
            <span class="n">gt_matched_classes</span> <span class="o">=</span> <span class="n">gt_matched_classes</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
            <span class="n">fg_mask</span> <span class="o">=</span> <span class="n">fg_mask</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
            <span class="n">pred_ious_this_matching</span> <span class="o">=</span> <span class="n">pred_ious_this_matching</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
            <span class="n">matched_gt_inds</span> <span class="o">=</span> <span class="n">matched_gt_inds</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">gt_matched_classes</span><span class="p">,</span> <span class="n">fg_mask</span><span class="p">,</span> <span class="n">pred_ious_this_matching</span><span class="p">,</span> <span class="n">matched_gt_inds</span><span class="p">,</span> <span class="n">num_fg</span></div>

<div class="viewcode-block" id="YoloXDetectionLoss.get_in_boxes_info"><a class="viewcode-back" href="../../../../super_gradients.training.html#super_gradients.training.losses.YoloXDetectionLoss.get_in_boxes_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_in_boxes_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gt_bboxes_per_image</span><span class="p">,</span> <span class="n">expanded_strides</span><span class="p">,</span> <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">total_num_anchors</span><span class="p">,</span> <span class="n">num_gt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a mask for all cells, mask in only foreground: cells that have a center located:</span>
<span class="sd">            * withing a GT box;</span>
<span class="sd">            OR</span>
<span class="sd">            * within a fixed radius around a GT box (center sampling);</span>

<span class="sd">        :param num_gt: int: Number of ground trunth targets in the image.</span>
<span class="sd">        :param total_num_anchors: int: Sum of all grid cells.</span>
<span class="sd">        :param gt_bboxes_per_image: torch.Tensor: Tensor of gt bboxes for  the image, shape: (num_gt, 4).</span>
<span class="sd">        :param expanded_strides: torch.Tensor: Stride of the output grid the prediction is coming from,</span>
<span class="sd">            shape (1 x num_cells x 1).</span>
<span class="sd">        :param x_shifts: torch.Tensor: X&#39;s in cell coordinates, shape (1,num_cells,1).</span>
<span class="sd">        :param y_shifts: torch.Tensor: Y&#39;s in cell coordinates, shape (1,num_cells,1).</span>

<span class="sd">        :return is_in_boxes_anchor, is_in_boxes_and_center</span>
<span class="sd">            where:</span>
<span class="sd">             - is_in_boxes_anchor masks the cells that their cell center is  inside a gt bbox and within</span>
<span class="sd">                self.center_sampling_radius cells away, without reduction (i.e shape=(num_gts, num_fgs))</span>
<span class="sd">             - is_in_boxes_and_center masks the cells that their center is either inside a gt bbox or within</span>
<span class="sd">                self.center_sampling_radius cells away, shape (num_fgs)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">expanded_strides_per_image</span> <span class="o">=</span> <span class="n">expanded_strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># cell coordinates, shape [n_predictions] -&gt; repeated to [n_gts, n_predictions]</span>
        <span class="n">x_shifts_per_image</span> <span class="o">=</span> <span class="n">x_shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">expanded_strides_per_image</span>
        <span class="n">y_shifts_per_image</span> <span class="o">=</span> <span class="n">y_shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">expanded_strides_per_image</span>
        <span class="n">x_centers_per_image</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_shifts_per_image</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">expanded_strides_per_image</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_gt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y_centers_per_image</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_shifts_per_image</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">expanded_strides_per_image</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_gt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># FIND CELL CENTERS THAT ARE WITHIN GROUND TRUTH BOXES</span>

        <span class="c1"># ground truth boxes, shape [n_gts] -&gt; repeated to [n_gts, n_predictions]</span>
        <span class="c1"># from (c1, c2, w, h) to left, right, top, bottom</span>
        <span class="n">gt_bboxes_per_image_l</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_num_anchors</span><span class="p">)</span>
        <span class="n">gt_bboxes_per_image_r</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_num_anchors</span><span class="p">)</span>
        <span class="n">gt_bboxes_per_image_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_num_anchors</span><span class="p">)</span>
        <span class="n">gt_bboxes_per_image_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_num_anchors</span><span class="p">)</span>

        <span class="c1"># check which cell centers lay within the ground truth boxes</span>
        <span class="n">b_l</span> <span class="o">=</span> <span class="n">x_centers_per_image</span> <span class="o">-</span> <span class="n">gt_bboxes_per_image_l</span>  <span class="c1"># x - l &gt; 0 when l is on the lest from x</span>
        <span class="n">b_r</span> <span class="o">=</span> <span class="n">gt_bboxes_per_image_r</span> <span class="o">-</span> <span class="n">x_centers_per_image</span>
        <span class="n">b_t</span> <span class="o">=</span> <span class="n">y_centers_per_image</span> <span class="o">-</span> <span class="n">gt_bboxes_per_image_t</span>
        <span class="n">b_b</span> <span class="o">=</span> <span class="n">gt_bboxes_per_image_b</span> <span class="o">-</span> <span class="n">y_centers_per_image</span>
        <span class="n">bbox_deltas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">b_l</span><span class="p">,</span> <span class="n">b_t</span><span class="p">,</span> <span class="n">b_r</span><span class="p">,</span> <span class="n">b_b</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># shape [n_gts, n_predictions]</span>

        <span class="c1"># to claim that a cell center is inside a gt box all 4 differences calculated above should be positive</span>
        <span class="n">is_in_boxes</span> <span class="o">=</span> <span class="n">bbox_deltas</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mf">0.0</span>  <span class="c1"># shape [n_gts, n_predictions]</span>
        <span class="n">is_in_boxes_all</span> <span class="o">=</span> <span class="n">is_in_boxes</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="c1"># shape [n_predictions], whether a cell is inside at least one gt</span>

        <span class="c1"># FIND CELL CENTERS THAT ARE WITHIN +- self.center_sampling_radius CELLS FROM GROUND TRUTH BOXES CENTERS</span>

        <span class="c1"># define fake boxes: instead of ground truth boxes step +- self.center_sampling_radius from their centers</span>
        <span class="n">gt_bboxes_per_image_l</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">total_num_anchors</span>
        <span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_sampling_radius</span> <span class="o">*</span> <span class="n">expanded_strides_per_image</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gt_bboxes_per_image_r</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">total_num_anchors</span>
        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_sampling_radius</span> <span class="o">*</span> <span class="n">expanded_strides_per_image</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gt_bboxes_per_image_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">total_num_anchors</span>
        <span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_sampling_radius</span> <span class="o">*</span> <span class="n">expanded_strides_per_image</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gt_bboxes_per_image_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_bboxes_per_image</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">total_num_anchors</span>
        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_sampling_radius</span> <span class="o">*</span> <span class="n">expanded_strides_per_image</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">c_l</span> <span class="o">=</span> <span class="n">x_centers_per_image</span> <span class="o">-</span> <span class="n">gt_bboxes_per_image_l</span>
        <span class="n">c_r</span> <span class="o">=</span> <span class="n">gt_bboxes_per_image_r</span> <span class="o">-</span> <span class="n">x_centers_per_image</span>
        <span class="n">c_t</span> <span class="o">=</span> <span class="n">y_centers_per_image</span> <span class="o">-</span> <span class="n">gt_bboxes_per_image_t</span>
        <span class="n">c_b</span> <span class="o">=</span> <span class="n">gt_bboxes_per_image_b</span> <span class="o">-</span> <span class="n">y_centers_per_image</span>
        <span class="n">center_deltas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">c_l</span><span class="p">,</span> <span class="n">c_t</span><span class="p">,</span> <span class="n">c_r</span><span class="p">,</span> <span class="n">c_b</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">is_in_centers</span> <span class="o">=</span> <span class="n">center_deltas</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
        <span class="n">is_in_centers_all</span> <span class="o">=</span> <span class="n">is_in_centers</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># in boxes OR in centers</span>
        <span class="n">is_in_boxes_anchor</span> <span class="o">=</span> <span class="n">is_in_boxes_all</span> <span class="o">|</span> <span class="n">is_in_centers_all</span>

        <span class="c1"># in boxes AND in centers, preserving a shape [num_GTs x num_FGs]</span>
        <span class="n">is_in_boxes_and_center</span> <span class="o">=</span> <span class="n">is_in_boxes</span><span class="p">[:,</span> <span class="n">is_in_boxes_anchor</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">is_in_centers</span><span class="p">[:,</span> <span class="n">is_in_boxes_anchor</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">is_in_boxes_anchor</span><span class="p">,</span> <span class="n">is_in_boxes_and_center</span></div>

<div class="viewcode-block" id="YoloXDetectionLoss.dynamic_k_matching"><a class="viewcode-back" href="../../../../super_gradients.training.html#super_gradients.training.losses.YoloXDetectionLoss.dynamic_k_matching">[docs]</a>    <span class="k">def</span> <span class="nf">dynamic_k_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">pair_wise_ious</span><span class="p">,</span> <span class="n">gt_classes</span><span class="p">,</span> <span class="n">num_gt</span><span class="p">,</span> <span class="n">fg_mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param cost:            pairwise cost, [num_FGs x num_GTs]</span>
<span class="sd">        :param pair_wise_ious:  pairwise IoUs, [num_FGs x num_GTs]</span>
<span class="sd">        :param gt_classes:      class of each GT</span>
<span class="sd">        :param num_gt:          number of GTs</span>

<span class="sd">        :return num_fg, (number of foregrounds)</span>
<span class="sd">                gt_matched_classes, (the classes that have been matched with fgs)</span>
<span class="sd">                pred_ious_this_matching</span>
<span class="sd">                matched_gt_inds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a matrix with shape [num_GTs x num_FGs]</span>
        <span class="n">matching_matrix</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="c1"># for each GT get a dynamic k of foregrounds with a minimum cost: k = int(sum[top 10 IoUs])</span>
        <span class="n">ious_in_boxes_matrix</span> <span class="o">=</span> <span class="n">pair_wise_ious</span>
        <span class="n">n_candidate_k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">ious_in_boxes_matrix</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">topk_ious</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="n">ious_in_boxes_matrix</span><span class="p">,</span> <span class="n">n_candidate_k</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dynamic_ks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">topk_ious</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">int</span><span class="p">(),</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dynamic_ks</span> <span class="o">=</span> <span class="n">dynamic_ks</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gt_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gt</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">pos_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="n">cost</span><span class="p">[</span><span class="n">gt_idx</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">dynamic_ks</span><span class="p">[</span><span class="n">gt_idx</span><span class="p">],</span> <span class="n">largest</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;cost[gt_idx]: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cost</span><span class="p">[</span><span class="n">gt_idx</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; dynamic_ks[gt_idx]L &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dynamic_ks</span><span class="p">[</span><span class="n">gt_idx</span><span class="p">]))</span>
            <span class="n">matching_matrix</span><span class="p">[</span><span class="n">gt_idx</span><span class="p">][</span><span class="n">pos_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">del</span> <span class="n">topk_ious</span><span class="p">,</span> <span class="n">dynamic_ks</span><span class="p">,</span> <span class="n">pos_idx</span>

        <span class="c1"># leave at most one GT per foreground, chose the one with the smallest cost</span>
        <span class="n">anchor_matching_gt</span> <span class="o">=</span> <span class="n">matching_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">anchor_matching_gt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">cost_argmin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cost</span><span class="p">[:,</span> <span class="n">anchor_matching_gt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">matching_matrix</span><span class="p">[:,</span> <span class="n">anchor_matching_gt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">0</span>
            <span class="n">matching_matrix</span><span class="p">[</span><span class="n">cost_argmin</span><span class="p">,</span> <span class="n">anchor_matching_gt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">fg_mask_inboxes</span> <span class="o">=</span> <span class="n">matching_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">num_fg</span> <span class="o">=</span> <span class="n">fg_mask_inboxes</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="n">fg_mask</span><span class="p">[</span><span class="n">fg_mask</span><span class="o">.</span><span class="n">clone</span><span class="p">()]</span> <span class="o">=</span> <span class="n">fg_mask_inboxes</span>

        <span class="n">matched_gt_inds</span> <span class="o">=</span> <span class="n">matching_matrix</span><span class="p">[:,</span> <span class="n">fg_mask_inboxes</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gt_matched_classes</span> <span class="o">=</span> <span class="n">gt_classes</span><span class="p">[</span><span class="n">matched_gt_inds</span><span class="p">]</span>

        <span class="n">pred_ious_this_matching</span> <span class="o">=</span> <span class="p">(</span><span class="n">matching_matrix</span> <span class="o">*</span> <span class="n">pair_wise_ious</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">fg_mask_inboxes</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">num_fg</span><span class="p">,</span> <span class="n">gt_matched_classes</span><span class="p">,</span> <span class="n">pred_ious_this_matching</span><span class="p">,</span> <span class="n">matched_gt_inds</span></div></div>


<div class="viewcode-block" id="YoloXFastDetectionLoss"><a class="viewcode-back" href="../../../../super_gradients.training.html#super_gradients.training.losses.YoloXFastDetectionLoss">[docs]</a><span class="k">class</span> <span class="nc">YoloXFastDetectionLoss</span><span class="p">(</span><span class="n">YoloXDetectionLoss</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A completely new implementation of YOLOX loss.</span>
<span class="sd">    This is NOT an equivalent implementation to the regular yolox loss.</span>

<span class="sd">    * Completely avoids using loops compared to the nested loops in the original implementation.</span>
<span class="sd">        As a result runs much faster (speedup depends on the type of GPUs, their count, the batch size, etc.).</span>
<span class="sd">    * Tensors format is very different the original implementation.</span>
<span class="sd">        Tensors contain image ids, ground truth ids and anchor ids as values to support variable length data.</span>
<span class="sd">    * There are differences in terms of the algorithm itself:</span>
<span class="sd">    1. When computing a dynamic k for a ground truth,</span>
<span class="sd">        in the original implementation they consider the sum of top 10 predictions sorted by ious among the initial</span>
<span class="sd">        foregrounds of any ground truth in the image,</span>
<span class="sd">        while in our implementation we consider only the initial foreground of that particular ground truth.</span>
<span class="sd">        To compensate for that difference we introduce the dynamic_ks_bias hyperparamter which makes the dynamic ks larger.</span>
<span class="sd">    2. When computing the k matched detections for a ground truth,</span>
<span class="sd">        in the original implementation they consider the initial foregrounds of any ground truth in the image as candidates,</span>
<span class="sd">        while in our implementation we consider only the initial foreground of that particular ground truth as candidates.</span>
<span class="sd">        We believe that this difference is minor.</span>

<span class="sd">    :param dynamic_ks_bias: hyperparameter to compensate for the discrepancies between the regular loss and this loss.</span>
<span class="sd">    :param sync_num_fgs:    sync num of fgs.</span>
<span class="sd">                            Can be used for DDP training.</span>
<span class="sd">    :param obj_loss_fix:    devide by total of num anchors instead num of matching fgs.</span>
<span class="sd">                            Can be used for objectness loss.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">use_l1</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">center_sampling_radius</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">iou_type</span><span class="o">=</span><span class="s2">&quot;iou&quot;</span><span class="p">,</span> <span class="n">dynamic_ks_bias</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">sync_num_fgs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">obj_loss_fix</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">use_l1</span><span class="o">=</span><span class="n">use_l1</span><span class="p">,</span> <span class="n">center_sampling_radius</span><span class="o">=</span><span class="n">center_sampling_radius</span><span class="p">,</span> <span class="n">iou_type</span><span class="o">=</span><span class="n">iou_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_ks_bias</span> <span class="o">=</span> <span class="n">dynamic_ks_bias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sync_num_fgs</span> <span class="o">=</span> <span class="n">sync_num_fgs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_loss_fix</span> <span class="o">=</span> <span class="n">obj_loss_fix</span>

    <span class="k">def</span> <span class="nf">_compute_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">targets</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        L = L_objectness + L_iou + L_classification + 1[no_aug_epoch]*L_l1</span>
<span class="sd">        where:</span>
<span class="sd">            * L_iou, L_classification and L_l1 are calculated only between cells and targets that suit them;</span>
<span class="sd">            * L_objectness is calculated for all cells.</span>

<span class="sd">        L_classification:</span>
<span class="sd">            for cells that have suitable ground truths in their grid locations add BCEs</span>
<span class="sd">            to force a prediction of IoU with a GT in a multi-label way</span>
<span class="sd">            Coef: 1.</span>
<span class="sd">        L_iou:</span>
<span class="sd">            for cells that have suitable ground truths in their grid locations</span>
<span class="sd">            add (1 - IoU^2), IoU between a predicted box and each GT box, force maximum IoU</span>
<span class="sd">            Coef: 1.</span>
<span class="sd">        L_l1:</span>
<span class="sd">            for cells that have suitable ground truths in their grid locations</span>
<span class="sd">            l1 distance between the logits and GTs in “logits” format (the inverse of “logits to predictions” ops)</span>
<span class="sd">            Coef: 1[no_aug_epoch]</span>
<span class="sd">        L_objectness:</span>
<span class="sd">            for each cell add BCE with a label of 1 if there is GT assigned to the cell</span>
<span class="sd">            Coef: 5</span>

<span class="sd">        :param predictions:     output from all Yolo levels, each of shape</span>
<span class="sd">                                [Batch x Num_Anchors x GridSizeY x GridSizeX x (4 + 1 + Num_classes)]</span>
<span class="sd">        :param targets:         [Num_targets x (4 + 2)], values on dim 1 are: image id in a batch, class, box x y w h</span>

<span class="sd">        :return:                loss, all losses separately in a detached tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">expanded_strides</span><span class="p">,</span> <span class="n">transformed_outputs</span><span class="p">,</span> <span class="n">raw_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_predictions</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>

        <span class="n">bbox_preds</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>  <span class="c1"># [batch, n_anchors_all, 4]</span>
        <span class="n">obj_preds</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>  <span class="c1"># [batch, n_anchors_all, 1]</span>
        <span class="n">cls_preds</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">5</span><span class="p">:]</span>  <span class="c1"># [batch, n_anchors_all, n_cls]</span>

        <span class="c1"># assign cells to ground truths, at most one GT per cell</span>
        <span class="n">matched_fg_ids</span><span class="p">,</span> <span class="n">matched_gt_classes</span><span class="p">,</span> <span class="n">matched_gt_ids</span><span class="p">,</span> <span class="n">matched_img_ids</span><span class="p">,</span> <span class="n">matched_ious</span><span class="p">,</span> <span class="n">flattened_gts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_matching</span><span class="p">(</span>
            <span class="n">bbox_preds</span><span class="p">,</span> <span class="n">cls_preds</span><span class="p">,</span> <span class="n">obj_preds</span><span class="p">,</span> <span class="n">expanded_strides</span><span class="p">,</span> <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">targets</span>
        <span class="p">)</span>

        <span class="n">num_gts</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">flattened_gts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">num_fg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">matched_gt_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">total_num_anchors</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">transformed_outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">cls_targets</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">matched_gt_classes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="p">)</span> <span class="o">*</span> <span class="n">matched_ious</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">obj_targets</span> <span class="o">=</span> <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">new_zeros</span><span class="p">((</span><span class="n">transformed_outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">obj_targets</span><span class="p">[</span><span class="n">matched_img_ids</span><span class="p">,</span> <span class="n">matched_fg_ids</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">reg_targets</span> <span class="o">=</span> <span class="n">flattened_gts</span><span class="p">[</span><span class="n">matched_gt_ids</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_l1</span><span class="p">:</span>
            <span class="n">l1_targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_l1_target</span><span class="p">(</span>
                <span class="n">transformed_outputs</span><span class="o">.</span><span class="n">new_zeros</span><span class="p">((</span><span class="n">num_fg</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span>
                <span class="n">flattened_gts</span><span class="p">[</span><span class="n">matched_gt_ids</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">:],</span>
                <span class="n">expanded_strides</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()[</span><span class="n">matched_fg_ids</span><span class="p">],</span>
                <span class="n">x_shifts</span><span class="o">=</span><span class="n">x_shifts</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()[</span><span class="n">matched_fg_ids</span><span class="p">],</span>
                <span class="n">y_shifts</span><span class="o">=</span><span class="n">y_shifts</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()[</span><span class="n">matched_fg_ids</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_num_fgs</span> <span class="ow">and</span> <span class="n">dist</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">WORLD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_fg</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">scalar_tensor</span><span class="p">(</span><span class="n">num_fg</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">matched_gt_ids</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">dist</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">num_fg</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">_distributed_c10d</span><span class="o">.</span><span class="n">ReduceOp</span><span class="o">.</span><span class="n">AVG</span><span class="p">)</span>

        <span class="n">loss_iou</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iou_loss</span><span class="p">(</span><span class="n">bbox_preds</span><span class="p">[</span><span class="n">matched_img_ids</span><span class="p">,</span> <span class="n">matched_fg_ids</span><span class="p">],</span> <span class="n">reg_targets</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">num_fg</span>
        <span class="n">loss_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcewithlog_loss</span><span class="p">(</span><span class="n">obj_preds</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">obj_targets</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_num_anchors</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_loss_fix</span> <span class="k">else</span> <span class="n">num_fg</span><span class="p">)</span>
        <span class="n">loss_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcewithlog_loss</span><span class="p">(</span><span class="n">cls_preds</span><span class="p">[</span><span class="n">matched_img_ids</span><span class="p">,</span> <span class="n">matched_fg_ids</span><span class="p">],</span> <span class="n">cls_targets</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">num_fg</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_l1</span><span class="p">:</span>
            <span class="n">loss_l1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l1_loss</span><span class="p">(</span><span class="n">raw_outputs</span><span class="p">[</span><span class="n">matched_img_ids</span><span class="p">,</span> <span class="n">matched_fg_ids</span><span class="p">],</span> <span class="n">l1_targets</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">num_fg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss_l1</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">reg_weight</span> <span class="o">=</span> <span class="mf">5.0</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">reg_weight</span> <span class="o">*</span> <span class="n">loss_iou</span> <span class="o">+</span> <span class="n">loss_obj</span> <span class="o">+</span> <span class="n">loss_cls</span> <span class="o">+</span> <span class="n">loss_l1</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">loss</span><span class="p">,</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">loss_iou</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">loss_obj</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">loss_cls</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">loss_l1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">transformed_outputs</span><span class="o">.</span><span class="n">device</span><span class="p">),</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">num_fg</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_gts</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">transformed_outputs</span><span class="o">.</span><span class="n">device</span><span class="p">),</span>
                    <span class="n">loss</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_initial_matching</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">gt_bboxes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">expanded_strides</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">x_shifts</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get candidates using a mask for all cells.</span>
<span class="sd">        Mask in only foreground cells that have a center located:</span>
<span class="sd">            * withing a GT box (param: is_in_boxes);</span>
<span class="sd">            OR</span>
<span class="sd">            * within a fixed radius around a GT box (center sampling) (param: is_in_centers);</span>

<span class="sd">        return:</span>
<span class="sd">            initial_matching: get a list of candidates pairs of (gt box id, anchor box id) based on cell = is_in_boxes | is_in_centers.</span>
<span class="sd">                              shape: [num_candidates, 2]</span>
<span class="sd">            strong candidate mask: get a list whether a candidate is a strong one or not.</span>
<span class="sd">                                   strong candidate is a cell from is_in_boxes &amp; is_in_centers.</span>
<span class="sd">                                   shape: [num_candidates].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_x_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_shifts</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">expanded_strides</span>
        <span class="n">cell_y_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_shifts</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">expanded_strides</span>

        <span class="n">gt_bboxes_x_centers</span> <span class="o">=</span> <span class="n">gt_bboxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">gt_bboxes_y_centers</span> <span class="o">=</span> <span class="n">gt_bboxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">gt_bboxes_half_w</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">gt_bboxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">gt_bboxes_half_h</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">gt_bboxes</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">is_in_boxes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">cell_x_centers</span> <span class="o">&gt;</span> <span class="n">gt_bboxes_x_centers</span> <span class="o">-</span> <span class="n">gt_bboxes_half_w</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">gt_bboxes_x_centers</span> <span class="o">+</span> <span class="n">gt_bboxes_half_w</span> <span class="o">&gt;</span> <span class="n">cell_x_centers</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">cell_y_centers</span> <span class="o">&gt;</span> <span class="n">gt_bboxes_y_centers</span> <span class="o">-</span> <span class="n">gt_bboxes_half_h</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">gt_bboxes_y_centers</span> <span class="o">+</span> <span class="n">gt_bboxes_half_h</span> <span class="o">&gt;</span> <span class="n">cell_y_centers</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">radius_shifts</span> <span class="o">=</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">expanded_strides</span>

        <span class="n">is_in_centers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">cell_x_centers</span> <span class="o">+</span> <span class="n">radius_shifts</span> <span class="o">&gt;</span> <span class="n">gt_bboxes_x_centers</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">gt_bboxes_x_centers</span> <span class="o">&gt;</span> <span class="n">cell_x_centers</span> <span class="o">-</span> <span class="n">radius_shifts</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">cell_y_centers</span> <span class="o">+</span> <span class="n">radius_shifts</span> <span class="o">&gt;</span> <span class="n">gt_bboxes_y_centers</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">gt_bboxes_y_centers</span> <span class="o">&gt;</span> <span class="n">cell_y_centers</span> <span class="o">-</span> <span class="n">radius_shifts</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">initial_mask</span> <span class="o">=</span> <span class="n">is_in_boxes</span> <span class="o">|</span> <span class="n">is_in_centers</span>
        <span class="n">initial_matching</span> <span class="o">=</span> <span class="n">initial_mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">strong_candidate_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_in_boxes</span> <span class="o">&amp;</span> <span class="n">is_in_centers</span><span class="p">)[</span><span class="n">initial_mask</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">initial_matching</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">initial_matching</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">strong_candidate_mask</span>

    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_compute_matching</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bbox_preds</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">cls_preds</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">obj_preds</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">expanded_strides</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">x_shifts</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">y_shifts</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">ious_loss_cost_coeff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">outside_boxes_and_center_cost_coeff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100000.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Match cells to ground truth:</span>
<span class="sd">            * at most 1 GT per cell</span>
<span class="sd">            * dynamic number of cells per GT</span>

<span class="sd">        :param bbox_preds: predictions of bounding boxes. shape [batch, n_anchors_all, 4]</span>
<span class="sd">        :param cls_preds:  predictions of class.          shape [batch, n_anchors_all, n_cls]</span>
<span class="sd">        :param obj_preds:  predictions for objectness.    shape [batch, n_anchors_all, 1]</span>
<span class="sd">        :param expanded_strides:  stride of the output grid the prediction is coming from. shape [1, n_anchors_all]</span>
<span class="sd">        :param x_shifts: x coordinate on the grid cell the prediction is coming from.      shape [1, n_anchors_all]</span>
<span class="sd">        :param y_shifts: y coordinate on the grid cell the prediction is coming from.      shape [1, n_anchors_all]</span>
<span class="sd">        :param labels:   labels for each grid cell.  shape [n_anchors_all, (4 + 2)]</span>
<span class="sd">        :return: candidate_fg_ids       shape [num_fg]</span>
<span class="sd">                 candidate_gt_classes   shape [num_fg]</span>
<span class="sd">                 candidate_gt_ids       shape [num_fg]</span>
<span class="sd">                 candidate_img_ids      shape [num_fg]</span>
<span class="sd">                 candidate_ious         shape [num_fg]</span>
<span class="sd">                 flattened_gts          shape [num_gts, 5]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">flattened_gts</span><span class="p">,</span> <span class="n">gt_id_to_img_id</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">labels</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="c1"># COMPUTE CANDIDATES</span>
        <span class="n">candidate_gt_ids</span><span class="p">,</span> <span class="n">candidate_fg_ids</span><span class="p">,</span> <span class="n">strong_candidate_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_initial_matching</span><span class="p">(</span><span class="n">flattened_gts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">expanded_strides</span><span class="p">,</span> <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">)</span>
        <span class="n">candidate_img_ids</span> <span class="o">=</span> <span class="n">gt_id_to_img_id</span><span class="p">[</span><span class="n">candidate_gt_ids</span><span class="p">]</span>
        <span class="n">candidate_gts_bbox</span> <span class="o">=</span> <span class="n">flattened_gts</span><span class="p">[</span><span class="n">candidate_gt_ids</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">candidate_det_bbox</span> <span class="o">=</span> <span class="n">bbox_preds</span><span class="p">[</span><span class="n">candidate_img_ids</span><span class="p">,</span> <span class="n">candidate_fg_ids</span><span class="p">]</span>

        <span class="c1"># COMPUTE DYNAMIC KS</span>
        <span class="n">candidate_ious</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_pairwise_bbox_iou</span><span class="p">(</span><span class="n">candidate_gts_bbox</span><span class="p">,</span> <span class="n">candidate_det_bbox</span><span class="p">,</span> <span class="n">xyxy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dynamic_ks</span><span class="p">,</span> <span class="n">matching_index_to_dynamic_k_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dynamic_ks</span><span class="p">(</span><span class="n">candidate_gt_ids</span><span class="p">,</span> <span class="n">candidate_ious</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_ks_bias</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">candidate_gts_bbox</span><span class="p">,</span> <span class="n">candidate_det_bbox</span>

        <span class="c1"># ORDER CANDIDATES BY COST</span>
        <span class="n">candidate_gt_classes</span> <span class="o">=</span> <span class="n">flattened_gts</span><span class="p">[</span><span class="n">candidate_gt_ids</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">cost_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_cost_order</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="p">,</span>
            <span class="n">candidate_img_ids</span><span class="p">,</span>
            <span class="n">candidate_gt_classes</span><span class="p">,</span>
            <span class="n">candidate_fg_ids</span><span class="p">,</span>
            <span class="n">candidate_ious</span><span class="p">,</span>
            <span class="n">cls_preds</span><span class="p">,</span>
            <span class="n">obj_preds</span><span class="p">,</span>
            <span class="n">strong_candidate_mask</span><span class="p">,</span>
            <span class="n">ious_loss_cost_coeff</span><span class="p">,</span>
            <span class="n">outside_boxes_and_center_cost_coeff</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">candidate_gt_ids</span> <span class="o">=</span> <span class="n">candidate_gt_ids</span><span class="p">[</span><span class="n">cost_order</span><span class="p">]</span>
        <span class="n">candidate_gt_classes</span> <span class="o">=</span> <span class="n">candidate_gt_classes</span><span class="p">[</span><span class="n">cost_order</span><span class="p">]</span>
        <span class="n">candidate_img_ids</span> <span class="o">=</span> <span class="n">candidate_img_ids</span><span class="p">[</span><span class="n">cost_order</span><span class="p">]</span>
        <span class="n">candidate_fg_ids</span> <span class="o">=</span> <span class="n">candidate_fg_ids</span><span class="p">[</span><span class="n">cost_order</span><span class="p">]</span>
        <span class="n">candidate_ious</span> <span class="o">=</span> <span class="n">candidate_ious</span><span class="p">[</span><span class="n">cost_order</span><span class="p">]</span>
        <span class="n">matching_index_to_dynamic_k_index</span> <span class="o">=</span> <span class="n">matching_index_to_dynamic_k_index</span><span class="p">[</span><span class="n">cost_order</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">cost_order</span>

        <span class="c1"># FILTER MATCHING TO LOWEST K COST MATCHES PER GT</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ranks</span><span class="p">(</span><span class="n">candidate_gt_ids</span><span class="p">)</span>
        <span class="n">corresponding_dynamic_ks</span> <span class="o">=</span> <span class="n">dynamic_ks</span><span class="p">[</span><span class="n">matching_index_to_dynamic_k_index</span><span class="p">]</span>
        <span class="n">topk_mask</span> <span class="o">=</span> <span class="n">ranks</span> <span class="o">&lt;</span> <span class="n">corresponding_dynamic_ks</span>

        <span class="n">candidate_gt_ids</span> <span class="o">=</span> <span class="n">candidate_gt_ids</span><span class="p">[</span><span class="n">topk_mask</span><span class="p">]</span>
        <span class="n">candidate_gt_classes</span> <span class="o">=</span> <span class="n">candidate_gt_classes</span><span class="p">[</span><span class="n">topk_mask</span><span class="p">]</span>
        <span class="n">candidate_img_ids</span> <span class="o">=</span> <span class="n">candidate_img_ids</span><span class="p">[</span><span class="n">topk_mask</span><span class="p">]</span>
        <span class="n">candidate_fg_ids</span> <span class="o">=</span> <span class="n">candidate_fg_ids</span><span class="p">[</span><span class="n">topk_mask</span><span class="p">]</span>
        <span class="n">candidate_ious</span> <span class="o">=</span> <span class="n">candidate_ious</span><span class="p">[</span><span class="n">topk_mask</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">ranks</span><span class="p">,</span> <span class="n">topk_mask</span><span class="p">,</span> <span class="n">dynamic_ks</span><span class="p">,</span> <span class="n">matching_index_to_dynamic_k_index</span><span class="p">,</span> <span class="n">corresponding_dynamic_ks</span>

        <span class="c1"># FILTER MATCHING TO AT MOST 1 MATCH FOR DET BY TAKING THE LOWEST COST MATCH</span>
        <span class="n">candidate_img_and_fg_ids_combined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_candidates_img_id_fg_id</span><span class="p">(</span><span class="n">candidate_img_ids</span><span class="p">,</span> <span class="n">candidate_fg_ids</span><span class="p">)</span>
        <span class="n">top1_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_is_first_mask</span><span class="p">(</span><span class="n">candidate_img_and_fg_ids_combined</span><span class="p">)</span>
        <span class="n">candidate_gt_ids</span> <span class="o">=</span> <span class="n">candidate_gt_ids</span><span class="p">[</span><span class="n">top1_mask</span><span class="p">]</span>
        <span class="n">candidate_gt_classes</span> <span class="o">=</span> <span class="n">candidate_gt_classes</span><span class="p">[</span><span class="n">top1_mask</span><span class="p">]</span>
        <span class="n">candidate_fg_ids</span> <span class="o">=</span> <span class="n">candidate_fg_ids</span><span class="p">[</span><span class="n">top1_mask</span><span class="p">]</span>
        <span class="n">candidate_img_ids</span> <span class="o">=</span> <span class="n">candidate_img_ids</span><span class="p">[</span><span class="n">top1_mask</span><span class="p">]</span>
        <span class="n">candidate_ious</span> <span class="o">=</span> <span class="n">candidate_ious</span><span class="p">[</span><span class="n">top1_mask</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">candidate_fg_ids</span><span class="p">,</span> <span class="n">candidate_gt_classes</span><span class="p">,</span> <span class="n">candidate_gt_ids</span><span class="p">,</span> <span class="n">candidate_img_ids</span><span class="p">,</span> <span class="n">candidate_ious</span><span class="p">,</span> <span class="n">flattened_gts</span>

    <span class="k">def</span> <span class="nf">_combine_candidates_img_id_fg_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidate_img_ids</span><span class="p">,</span> <span class="n">candidate_anchor_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create one dim tensor with unique pairs of img_id and fg_id.</span>
<span class="sd">        e.g: candidate_img_ids = [0,1,0,0]</span>
<span class="sd">             candidate_fg_ids = [0,0,0,1]</span>
<span class="sd">             result = [0,1,0,2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">candidate_img_and_fg_ids_combined</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">candidate_img_ids</span><span class="p">,</span> <span class="n">candidate_anchor_ids</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">candidate_img_and_fg_ids_combined</span>

    <span class="k">def</span> <span class="nf">_compute_dynamic_ks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">ious</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">dynamic_ks_bias</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ids:                 ids of GTs, shape: [num_candidates]</span>
<span class="sd">        :param ious:                pairwise IoUs, shape: [num_candidates]</span>
<span class="sd">        :param dynamic_ks_bias:     multiply the resulted k to compensate the regular loss</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;ids must be of shape [num_candidates]&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ious</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;ious must be of shape [num_candidates]&quot;</span>
        <span class="k">assert</span> <span class="n">ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ious</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;num of ids.shape[0] must be the same as num of ious.shape[0]&quot;</span>
        <span class="c1"># sort ious and ids by ious</span>
        <span class="n">ious</span><span class="p">,</span> <span class="n">ious_argsort</span> <span class="o">=</span> <span class="n">ious</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">descending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">ious_argsort</span><span class="p">]</span>

        <span class="c1"># stable sort indices, so that ious are first sorted by id and second by value</span>
        <span class="n">ids</span><span class="p">,</span> <span class="n">ids_argsort</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ious</span> <span class="o">=</span> <span class="n">ious</span><span class="p">[</span><span class="n">ids_argsort</span><span class="p">]</span>

        <span class="n">unique_ids</span><span class="p">,</span> <span class="n">ids_index_to_unique_ids_index</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">unique_consecutive</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">num_unique_ids</span> <span class="o">=</span> <span class="n">unique_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">is_in_top_10</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">10</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">ids</span><span class="o">.</span><span class="n">device</span><span class="p">),</span> <span class="n">ids</span><span class="p">[</span><span class="mi">10</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">ids</span><span class="p">[:</span><span class="o">-</span><span class="mi">10</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_in_top_10</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="n">dynamic_ks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_unique_ids</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ious</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">ious</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">dynamic_ks</span><span class="o">.</span><span class="n">index_put_</span><span class="p">((</span><span class="n">ids_index_to_unique_ids_index</span><span class="p">,),</span> <span class="n">is_in_top_10</span> <span class="o">*</span> <span class="n">ious</span><span class="p">,</span> <span class="n">accumulate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dynamic_ks_bias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dynamic_ks</span> <span class="o">*=</span> <span class="n">dynamic_ks_bias</span>
        <span class="n">dynamic_ks</span> <span class="o">=</span> <span class="n">dynamic_ks</span><span class="o">.</span><span class="n">long</span><span class="p">()</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">all_argsort</span> <span class="o">=</span> <span class="n">ious_argsort</span><span class="p">[</span><span class="n">ids_argsort</span><span class="p">]</span>
        <span class="n">inverse_all_argsort</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ious_argsort</span><span class="p">)</span>
        <span class="n">inverse_all_argsort</span><span class="p">[</span><span class="n">all_argsort</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">all_argsort</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">all_argsort</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">all_argsort</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dynamic_ks</span><span class="p">,</span> <span class="n">ids_index_to_unique_ids_index</span><span class="p">[</span><span class="n">inverse_all_argsort</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_cost_order</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_classes</span><span class="p">,</span>
        <span class="n">candidate_gt_img_ids</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">candidate_gt_classes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">candidate_anchor_ids</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">candidate_ious</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">cls_preds</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">obj_preds</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">strong_candidate_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">ious_loss_cost_coeff</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">outside_boxes_and_center_cost_coeff</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">gt_cls_per_image</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">candidate_gt_classes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="n">num_classes</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">autocast</span><span class="p">(</span><span class="n">enabled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">cls_preds_</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cls_preds</span><span class="p">[</span><span class="n">candidate_gt_img_ids</span><span class="p">,</span> <span class="n">candidate_anchor_ids</span><span class="p">]</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">sigmoid_</span><span class="p">()</span>
                <span class="o">*</span> <span class="n">obj_preds</span><span class="p">[</span><span class="n">candidate_gt_img_ids</span><span class="p">,</span> <span class="n">candidate_anchor_ids</span><span class="p">]</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">sigmoid_</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">pair_wise_cls_cost</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">binary_cross_entropy</span><span class="p">(</span><span class="n">cls_preds_</span><span class="o">.</span><span class="n">sqrt_</span><span class="p">(),</span> <span class="n">gt_cls_per_image</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">ious_cost</span> <span class="o">=</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">candidate_ious</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">pair_wise_cls_cost</span> <span class="o">+</span> <span class="n">ious_loss_cost_coeff</span> <span class="o">*</span> <span class="n">ious_cost</span> <span class="o">+</span> <span class="n">outside_boxes_and_center_cost_coeff</span> <span class="o">*</span> <span class="n">strong_candidate_mask</span><span class="o">.</span><span class="n">logical_not</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cost</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_calculate_pairwise_bbox_iou</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bboxes_a</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">bboxes_b</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">xyxy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bboxes_a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">bboxes_b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>

        <span class="k">if</span> <span class="n">xyxy</span><span class="p">:</span>
            <span class="n">tl</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bboxes_a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">bboxes_b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">br</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bboxes_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">bboxes_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span>
            <span class="n">area_a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">bboxes_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bboxes_a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">area_b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">bboxes_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bboxes_b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tl</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="p">(</span><span class="n">bboxes_a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bboxes_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                <span class="p">(</span><span class="n">bboxes_b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bboxes_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">br</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                <span class="p">(</span><span class="n">bboxes_a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">bboxes_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                <span class="p">(</span><span class="n">bboxes_b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">bboxes_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="n">area_a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">bboxes_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">area_b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">bboxes_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">en</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">&lt;</span> <span class="n">br</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">area_i</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">br</span> <span class="o">-</span> <span class="n">tl</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">en</span>
        <span class="k">return</span> <span class="n">area_i</span> <span class="o">/</span> <span class="p">(</span><span class="n">area_a</span> <span class="o">+</span> <span class="n">area_b</span> <span class="o">-</span> <span class="n">area_i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_ranks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">ids</span><span class="p">,</span> <span class="n">ids_argsort</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">is_not_first</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">ids</span><span class="o">.</span><span class="n">device</span><span class="p">),</span> <span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">ids</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_not_first</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="n">subtract</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ids_argsort</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">ids</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">subtract</span><span class="p">[</span><span class="n">is_not_first</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">subtract</span> <span class="o">=</span> <span class="n">subtract</span><span class="o">.</span><span class="n">cummax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ids_argsort</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">ids</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-</span> <span class="n">subtract</span>

        <span class="n">inverse_argsort</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ids_argsort</span><span class="p">)</span>
        <span class="n">inverse_argsort</span><span class="p">[</span><span class="n">ids_argsort</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ids_argsort</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ids_argsort</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">ids_argsort</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rank</span><span class="p">[</span><span class="n">inverse_argsort</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_is_first_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter fg that matches two gts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span><span class="p">,</span> <span class="n">ids_argsort</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">is_first</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">ids</span><span class="o">.</span><span class="n">device</span><span class="p">),</span> <span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">ids</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_first</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="n">inverse_argsort</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ids_argsort</span><span class="p">)</span>
        <span class="n">inverse_argsort</span><span class="p">[</span><span class="n">ids_argsort</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ids_argsort</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ids_argsort</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">ids_argsort</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">is_first</span><span class="p">[</span><span class="n">inverse_argsort</span><span class="p">]</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, SuperGradients team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
