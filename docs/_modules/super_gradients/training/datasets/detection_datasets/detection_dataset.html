<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>super_gradients.training.datasets.detection_datasets.detection_dataset &mdash; SuperGradients 3.0.3 documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../../index.html" class="icon icon-home"> SuperGradients
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Welcome To SuperGradients</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html">Version 3 is out! Notebooks have been updated!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#build-with-supergradients">Build with SuperGradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#quick-installation">Quick Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#what-s-new">Whatâ€™s New</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#coming-soon">Coming soon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#table-of-content">Table of Content</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#getting-started">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#advanced-features">Advanced Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#installation-methods">Installation Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#implemented-model-architectures">Implemented Model Architectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#documentation">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#contributing">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#citation">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#community">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#license">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../welcome.html#deci-platform">Deci Platform</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Technical Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../super_gradients.common.html">Common package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../super_gradients.training.html">Training package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">SuperGradients</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
      <li>super_gradients.training.datasets.detection_datasets.detection_dataset</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for super_gradients.training.datasets.detection_datasets.detection_dataset</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">multiprocessing.pool</span> <span class="kn">import</span> <span class="n">ThreadPool</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">hashlib</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span>

<span class="kn">from</span> <span class="nn">super_gradients.common.decorators.factory_decorator</span> <span class="kn">import</span> <span class="n">resolve_param</span>
<span class="kn">from</span> <span class="nn">super_gradients.training.utils.detection_utils</span> <span class="kn">import</span> <span class="n">get_cls_posx_in_target</span><span class="p">,</span> <span class="n">DetectionTargetsFormat</span>
<span class="kn">from</span> <span class="nn">super_gradients.common.abstractions.abstract_logger</span> <span class="kn">import</span> <span class="n">get_logger</span>
<span class="kn">from</span> <span class="nn">super_gradients.training.transforms.transforms</span> <span class="kn">import</span> <span class="n">DetectionTransform</span><span class="p">,</span> <span class="n">DetectionTargetsFormatTransform</span>
<span class="kn">from</span> <span class="nn">super_gradients.training.exceptions.dataset_exceptions</span> <span class="kn">import</span> <span class="n">EmptyDatasetException</span>
<span class="kn">from</span> <span class="nn">super_gradients.common.factories.list_factory</span> <span class="kn">import</span> <span class="n">ListFactory</span>
<span class="kn">from</span> <span class="nn">super_gradients.common.factories.transforms_factory</span> <span class="kn">import</span> <span class="n">TransformsFactory</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="DetectionDataset"><a class="viewcode-back" href="../../../../../super_gradients.training.html#super_gradients.training.datasets.DetectionDataset">[docs]</a><span class="k">class</span> <span class="nc">DetectionDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Detection dataset.</span>

<span class="sd">    This is a boilerplate class to facilitate the implementation of datasets.</span>

<span class="sd">    HOW TO CREATE A DATASET THAT INHERITS FROM DetectionDataSet ?</span>
<span class="sd">        - Inherit from DetectionDataSet</span>
<span class="sd">        - implement the method self._load_annotation to return at least the fields &quot;target&quot; and &quot;img_path&quot;</span>
<span class="sd">        - Call super().__init__ with the required params.</span>
<span class="sd">                //!\\ super().__init__ will call self._load_annotation, so make sure that every required</span>
<span class="sd">                      attributes are set up before calling super().__init__ (ideally just call it last)</span>

<span class="sd">    WORKFLOW:</span>
<span class="sd">        - On instantiation:</span>
<span class="sd">            - All annotations are cached. If class_inclusion_list was specified, there is also subclassing at this step.</span>
<span class="sd">            - If cache is True, the images are also cached</span>

<span class="sd">        - On call (__getitem__) for a specific image index:</span>
<span class="sd">            - The image and annotations are grouped together in a dict called SAMPLE</span>
<span class="sd">            - the sample is processed according to th transform</span>
<span class="sd">            - Only the specified fields are returned by __getitem__</span>

<span class="sd">    TERMINOLOGY</span>
<span class="sd">        - TARGET:       Groundtruth, made of bboxes. The format can vary from one dataset to another</span>
<span class="sd">        - ANNOTATION:   Combination of targets (groundtruth) and metadata of the image, but without the image itself.</span>
<span class="sd">                            &gt; Has to include the fields &quot;target&quot; and &quot;img_path&quot;</span>
<span class="sd">                            &gt; Can include other fields like &quot;crowd_target&quot;, &quot;image_info&quot;, &quot;segmentation&quot;, ...</span>
<span class="sd">        - SAMPLE:       Outout of the dataset:</span>
<span class="sd">                            &gt; Has to include the fields &quot;target&quot; and &quot;image&quot;</span>
<span class="sd">                            &gt; Can include other fields like &quot;crowd_target&quot;, &quot;image_info&quot;, &quot;segmentation&quot;, ...</span>
<span class="sd">        - INDEX:        Refers to the index in the dataset.</span>
<span class="sd">        - SAMPLE ID:    Refers to the id of sample before droping any annotaion.</span>
<span class="sd">                            Let&#39;s imagine a situation where the downloaded data is made of 120 images but 20 were drop</span>
<span class="sd">                            because they had no annotation. In that case:</span>
<span class="sd">                                &gt; We have 120 samples so sample_id will be between 0 and 119</span>
<span class="sd">                                &gt; But only 100 will be indexed so index will be between 0 and 99</span>
<span class="sd">                                &gt; Therefore, we also have len(self) = 100</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@resolve_param</span><span class="p">(</span><span class="s2">&quot;transforms&quot;</span><span class="p">,</span> <span class="n">ListFactory</span><span class="p">(</span><span class="n">TransformsFactory</span><span class="p">()))</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_dir</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">input_dim</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">original_target_format</span><span class="p">:</span> <span class="n">DetectionTargetsFormat</span><span class="p">,</span>
        <span class="n">max_num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cache_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transforms</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DetectionTransform</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">all_classes_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">class_inclusion_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ignore_empty_annotations</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">target_fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Detection dataset.</span>

<span class="sd">        :param data_dir:                Where the data is stored</span>
<span class="sd">        :param input_dim:               Image size (when loaded, before transforms).</span>
<span class="sd">        :param original_target_format:  Format of targets stored on disk. raw data format, the output format might</span>
<span class="sd">                                        differ based on transforms.</span>
<span class="sd">        :param max_num_samples:         If not None, set the maximum size of the dataset by only indexing the first n annotations/images.</span>
<span class="sd">        :param cache:                   Whether to cache images or not.</span>
<span class="sd">        :param cache_dir:              Path to the directory where cached images will be stored in an optimized format.</span>
<span class="sd">        :param transforms:              List of transforms to apply sequentially on sample.</span>
<span class="sd">        :param all_classes_list:        All the class names.</span>
<span class="sd">        :param class_inclusion_list:    If not None,every class not included will be ignored.</span>
<span class="sd">        :param ignore_empty_annotations:        If True and class_inclusion_list not None, images without any target</span>
<span class="sd">                                                will be ignored.</span>
<span class="sd">        :param target_fields:                   List of the fields target fields. This has to include regular target,</span>
<span class="sd">                                                but can also include crowd target, segmentation target, ...</span>
<span class="sd">                                                It has to include at least &quot;target&quot; but can include other.</span>
<span class="sd">        :paran output_fields:                   Fields that will be outputed by __getitem__.</span>
<span class="sd">                                                It has to include at least &quot;image&quot; and &quot;target&quot; but can include other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">data_dir</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Path</span><span class="p">(</span><span class="n">data_dir</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Please make sure to download the data in the data directory (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

        <span class="c1"># Number of images that are avalaible(regardless of ignored images)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_available_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_data_source</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_available_samples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_available_samples</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_setup_data_source() should return the number of available samples but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_available_samples</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span> <span class="o">=</span> <span class="n">input_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_target_format</span> <span class="o">=</span> <span class="n">original_target_format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_num_samples</span> <span class="o">=</span> <span class="n">max_num_samples</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_classes_list</span> <span class="o">=</span> <span class="n">all_classes_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_inclusion_list</span> <span class="o">=</span> <span class="n">class_inclusion_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_inclusion_list</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_classes_list</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_classes_list</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">wrong_classes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_classes_list</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;class_inclusion_list includes classes that are not in all_classes_list: </span><span class="si">{</span><span class="n">wrong_classes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_empty_annotations</span> <span class="o">=</span> <span class="n">ignore_empty_annotations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_fields</span> <span class="o">=</span> <span class="n">target_fields</span> <span class="ow">or</span> <span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;target&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_fields</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;&quot;target&quot; is expected to be in the fields to subclass but it was not included&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_required_annotation_fields</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;img_path&quot;</span><span class="p">,</span> <span class="s2">&quot;resized_img_shape&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_annotations</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span> <span class="o">=</span> <span class="n">cache_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_imgs_padded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_images</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">output_fields</span> <span class="o">=</span> <span class="n">output_fields</span> <span class="ow">or</span> <span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_fields</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;image&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fields</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;output_fields must start with &quot;image&quot; and then &quot;target&quot;, followed by any other field&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_data_source</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set up the data source and store relevant objects as attributes.</span>

<span class="sd">        :return: Number of available samples, (i.e. how many images we have, regardless of any filter we might want to use)&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_load_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Load annotations associated to a specific sample.</span>
<span class="sd">        Please note that the targets should be resized according to self.input_dim!</span>

<span class="sd">        :param sample_id:   Id of the sample to load annotations from.</span>
<span class="sd">        :return:            Annotation, a dict with any field but has to include at least the fields specified in self._required_annotation_fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_cache_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Load all the annotations to memory to avoid opening files back and forth.</span>
<span class="sd">        :return: List of annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sample_id</span><span class="p">,</span> <span class="n">img_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_available_samples</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Caching annotations&quot;</span><span class="p">)):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_samples</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">img_annotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_annotation</span><span class="p">(</span><span class="n">img_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_required_annotation_fields</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">img_annotation</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;_load_annotation is expected to return at least the fields </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_required_annotation_fields</span><span class="si">}</span><span class="s2"> &quot;</span> <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">img_annotation</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_inclusion_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">img_annotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub_class_annotation</span><span class="p">(</span><span class="n">img_annotation</span><span class="p">)</span>

            <span class="n">is_annotation_empty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_annotation</span><span class="p">[</span><span class="n">field</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_fields</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_empty_annotations</span> <span class="ow">and</span> <span class="n">is_annotation_empty</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_annotation</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EmptyDatasetException</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Out of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_available_samples</span><span class="si">}</span><span class="s2"> images, not a single one was found with&quot;</span> <span class="sa">f</span><span class="s2">&quot;any of these classes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">class_inclusion_list</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">annotations</span>

    <span class="k">def</span> <span class="nf">_sub_class_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Subclass every field listed in self.target_fields. It could be targets, crowd_targets, ...</span>

<span class="sd">        :param annotation: Dict representing the annotation of a specific image</span>
<span class="sd">        :return:           Subclassed annotation if non empty after subclassing, otherwise None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls_posx</span> <span class="o">=</span> <span class="n">get_cls_posx_in_target</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">original_target_format</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_fields</span><span class="p">:</span>
            <span class="n">annotation</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub_class_target</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="n">annotation</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="n">cls_posx</span><span class="o">=</span><span class="n">cls_posx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">annotation</span>

    <span class="k">def</span> <span class="nf">_sub_class_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">cls_posx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sublass targets of a specific image.</span>

<span class="sd">        :param targets:     Target array to subclass of shape [n_targets, 5], 5 representing a bbox</span>
<span class="sd">        :param cls_posx:    Position of the class id in a bbox</span>
<span class="sd">                                ex: 0 if bbox of format label_xyxy | -1 if bbox of format xyxy_label</span>
<span class="sd">        :return:            Subclassed target</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">targets_kept</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="n">cls_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="n">cls_posx</span><span class="p">])</span>
            <span class="n">cls_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_classes_list</span><span class="p">[</span><span class="n">cls_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cls_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_inclusion_list</span><span class="p">:</span>
                <span class="c1"># Replace the target cls_id in self.all_classes_list by cls_id in self.class_inclusion_list</span>
                <span class="n">target</span><span class="p">[</span><span class="n">cls_posx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_inclusion_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cls_name</span><span class="p">)</span>
                <span class="n">targets_kept</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">targets_kept</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets_kept</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cache_images</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Cache the images. The cached image are stored in a file to be loaded faster mext time.</span>
<span class="sd">        :return: Cached images</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cache_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must specify a cache_dir if you want to cache your images.&quot;</span> <span class="s2">&quot;If you did not mean to use cache, please set cache=False &quot;</span><span class="p">)</span>
        <span class="n">cache_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">********************************************************************************</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;You are using cached images in RAM to accelerate training.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;This requires large system RAM.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;********************************************************************************&quot;</span>
        <span class="p">)</span>

        <span class="n">max_h</span><span class="p">,</span> <span class="n">max_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># The cache should be the same as long as the images and their sizes are the same</span>
        <span class="nb">hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">:</span>
            <span class="n">values_to_hash</span> <span class="o">=</span> <span class="p">[</span><span class="n">annotation</span><span class="p">[</span><span class="s2">&quot;resized_img_shape&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">annotation</span><span class="p">[</span><span class="s2">&quot;resized_img_shape&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">Path</span><span class="p">(</span><span class="n">annotation</span><span class="p">[</span><span class="s2">&quot;img_path&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values_to_hash</span><span class="p">:</span>
                <span class="nb">hash</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
        <span class="n">cache_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

        <span class="n">img_resized_cache_path</span> <span class="o">=</span> <span class="n">cache_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;img_resized_cache_</span><span class="si">{</span><span class="n">cache_hash</span><span class="si">}</span><span class="s2">.array&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">img_resized_cache_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Caching images for the first time. Be aware that this will stay in the disk until you delete it yourself.&quot;</span><span class="p">)</span>
            <span class="n">NUM_THREADs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
            <span class="n">loaded_images</span> <span class="o">=</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="n">NUM_THREADs</span><span class="p">)</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_resized_img</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">iterable</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

            <span class="c1"># Initialize placeholder for images</span>
            <span class="n">cached_imgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">img_resized_cache_path</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">max_h</span><span class="p">,</span> <span class="n">max_w</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w+&quot;</span><span class="p">)</span>

            <span class="c1"># Store images in the placeholder</span>
            <span class="n">loaded_images_pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">loaded_images</span><span class="p">),</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">loaded_images_pbar</span><span class="p">:</span>
                <span class="n">cached_imgs</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">cached_imgs</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="n">loaded_images_pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;You are using cached imgs!&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loading cached imgs...&quot;</span><span class="p">)</span>
        <span class="n">cached_imgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">img_resized_cache_path</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">max_h</span><span class="p">,</span> <span class="n">max_w</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cached_imgs</span>

    <span class="k">def</span> <span class="nf">_load_resized_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Load image, and resizes it to self.input_dim</span>
<span class="sd">        :param index:   Image index</span>
<span class="sd">        :return:        Resized image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_image</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">desired_size</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span>

        <span class="n">resized_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">img</span><span class="p">,</span> <span class="n">dsize</span><span class="o">=</span><span class="n">desired_size</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resized_img</span>

    <span class="k">def</span> <span class="nf">_load_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Loads image at index with its original resolution.</span>
<span class="sd">        :param index:   Image index</span>
<span class="sd">        :return:        Image in array format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;img_path&quot;</span><span class="p">]</span>

        <span class="n">img_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">img_file</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">img_file</span><span class="si">}</span><span class="s2"> was no found. Please make sure that the dataset was&quot;</span> <span class="sa">f</span><span class="s2">&quot;downloaded and that the path is correct&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear the cached images&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cached_imgs_padded&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_imgs_padded</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the length of the dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the sample post transforms at a specific index of the dataset.</span>
<span class="sd">        The output of this function will be collated to form batches.&quot;&quot;&quot;</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_transforms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sample</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sample</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The field </span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2"> must be present in the sample but was not found.&quot;</span> <span class="s2">&quot;Please check the output fields of your transforms.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fields</span><span class="p">)</span>

<div class="viewcode-block" id="DetectionDataset.get_random_item"><a class="viewcode-back" href="../../../../../super_gradients.training.html#super_gradients.training.datasets.DetectionDataset.get_random_item">[docs]</a>    <span class="k">def</span> <span class="nf">get_random_item</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_index</span><span class="p">()]</span></div>

<div class="viewcode-block" id="DetectionDataset.get_sample"><a class="viewcode-back" href="../../../../../super_gradients.training.html#super_gradients.training.datasets.DetectionDataset.get_sample">[docs]</a>    <span class="k">def</span> <span class="nf">get_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Get raw sample, before any transform (beside subclassing).</span>
<span class="sd">        :param index:   Image index</span>
<span class="sd">        :return:        Sample, i.e. a dictionary including at least &quot;image&quot; and &quot;target&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_resized_image</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="n">img</span><span class="p">,</span> <span class="o">**</span><span class="n">annotation</span><span class="p">}</span></div>

<div class="viewcode-block" id="DetectionDataset.get_resized_image"><a class="viewcode-back" href="../../../../../super_gradients.training.html#super_gradients.training.datasets.DetectionDataset.get_resized_image">[docs]</a>    <span class="k">def</span> <span class="nf">get_resized_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the resized image (i.e. either width or height reaches its input_dim) at a specific sample_id,</span>
<span class="sd">        either from cache or by loading from disk, based on self.cached_imgs_padded</span>
<span class="sd">        :param index:  Image index</span>
<span class="sd">        :return:       Resized image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">padded_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_imgs_padded</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">resized_height</span><span class="p">,</span> <span class="n">resized_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;resized_img_shape&quot;</span><span class="p">]</span>
            <span class="n">resized_image</span> <span class="o">=</span> <span class="n">padded_image</span><span class="p">[:</span><span class="n">resized_height</span><span class="p">,</span> <span class="p">:</span><span class="n">resized_width</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="n">resized_image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_resized_img</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="DetectionDataset.apply_transforms"><a class="viewcode-back" href="../../../../../super_gradients.training.html#super_gradients.training.datasets.DetectionDataset.apply_transforms">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies self.transforms sequentially to sample</span>

<span class="sd">        If a transforms has the attribute &#39;additional_samples_count&#39;, additional samples will be loaded and stored in</span>
<span class="sd">         sample[&quot;additional_samples&quot;] prior to applying it. Combining with the attribute &quot;non_empty_annotations&quot; will load</span>
<span class="sd">         only additional samples with objects in them.</span>

<span class="sd">        :param sample: Sample to apply the transforms on to (loaded with self.get_sample)</span>
<span class="sd">        :return: Transformed sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_additional_inputs_for_transform</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
            <span class="n">sample</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;additional_samples&quot;</span><span class="p">)</span>  <span class="c1"># additional_samples is not useful after the transform</span>
        <span class="k">return</span> <span class="n">sample</span></div>

    <span class="k">def</span> <span class="nf">_add_additional_inputs_for_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">transform</span><span class="p">:</span> <span class="n">DetectionTransform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add additional inputs required by a transform to the sample&quot;&quot;&quot;</span>
        <span class="n">additional_samples_count</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">additional_samples_count</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="s2">&quot;additional_samples_count&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">non_empty_annotations</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">non_empty_annotations</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="s2">&quot;non_empty_annotations&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">additional_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_random_samples</span><span class="p">(</span><span class="n">additional_samples_count</span><span class="p">,</span> <span class="n">non_empty_annotations</span><span class="p">)</span>
        <span class="n">sample</span><span class="p">[</span><span class="s2">&quot;additional_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">additional_samples</span>

<div class="viewcode-block" id="DetectionDataset.get_random_samples"><a class="viewcode-back" href="../../../../../super_gradients.training.html#super_gradients.training.datasets.DetectionDataset.get_random_samples">[docs]</a>    <span class="k">def</span> <span class="nf">get_random_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">non_empty_annotations_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Load random samples.</span>

<span class="sd">        :param count: The number of samples wanted</span>
<span class="sd">        :param non_empty_annotations_only: If true, only return samples with at least 1 annotation</span>
<span class="sd">        :return: A list of samples satisfying input params</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_random_sample</span><span class="p">(</span><span class="n">non_empty_annotations_only</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span></div>

<div class="viewcode-block" id="DetectionDataset.get_random_sample"><a class="viewcode-back" href="../../../../../super_gradients.training.html#super_gradients.training.datasets.DetectionDataset.get_random_sample">[docs]</a>    <span class="k">def</span> <span class="nf">get_random_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">non_empty_annotations_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">non_empty_annotations_only</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_random_non_empty_annotation_available_indexes</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_index</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_get_random_non_empty_annotation_available_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the index of a non-empty annotation.</span>
<span class="sd">        :return: Image index&quot;&quot;&quot;</span>
        <span class="n">target</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="p">[],</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_index</span><span class="p">()</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;target&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">_random_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a random index of this dataset&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_target_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">target_format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_target_format</span>
        <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">DetectionTargetsFormatTransform</span><span class="p">):</span>
                <span class="n">target_format</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">output_format</span>
        <span class="k">return</span> <span class="n">target_format</span>

<div class="viewcode-block" id="DetectionDataset.plot"><a class="viewcode-back" href="../../../../../super_gradients.training.html#super_gradients.training.datasets.DetectionDataset.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_samples_per_plot</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">n_plots</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">plot_transformed_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine samples of images with bbox into plots and display the result.</span>

<span class="sd">        :param max_samples_per_plot:    Maximum number of images to be displayed per plot</span>
<span class="sd">        :param n_plots:                 Number of plots to display (each plot being a combination of img with bbox)</span>
<span class="sd">        :param plot_transformed_data:   If True, the plot will be over samples after applying transforms (i.e. on __getitem__).</span>
<span class="sd">                                        If False, the plot will be over the raw samples (i.e. on get_sample)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plot_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">input_format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_target_format</span> <span class="k">if</span> <span class="n">plot_transformed_data</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_target_format</span>
        <span class="n">target_format_transform</span> <span class="o">=</span> <span class="n">DetectionTargetsFormatTransform</span><span class="p">(</span><span class="n">input_format</span><span class="o">=</span><span class="n">input_format</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="n">DetectionTargetsFormat</span><span class="o">.</span><span class="n">XYXY_LABEL</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">plot_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_plots</span><span class="p">):</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="n">n_subplot</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_samples_per_plot</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">img_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_samples_per_plot</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">img_i</span> <span class="o">+</span> <span class="n">plot_i</span> <span class="o">*</span> <span class="mi">16</span>

                <span class="k">if</span> <span class="n">plot_transformed_data</span><span class="p">:</span>
                    <span class="n">image</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">img_i</span> <span class="o">+</span> <span class="n">plot_i</span> <span class="o">*</span> <span class="mi">16</span><span class="p">]</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sample</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                    <span class="n">image</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">],</span> <span class="n">sample</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span>

                <span class="n">sample</span> <span class="o">=</span> <span class="n">target_format_transform</span><span class="p">({</span><span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="n">image</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">targets</span><span class="p">})</span>

                <span class="c1"># shape = [padding_size x 4] (The dataset will most likely pad the targets to a fixed dim)</span>
                <span class="n">boxes</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

                <span class="c1"># shape = [n_box x 4] (We remove padded boxes, which corresponds to boxes with only 0)</span>
                <span class="n">boxes</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[(</span><span class="n">boxes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">n_subplot</span><span class="p">,</span> <span class="n">n_subplot</span><span class="p">,</span> <span class="n">img_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">boxes</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;.-&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">plot_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">plot_counter</span> <span class="o">==</span> <span class="n">n_plots</span><span class="p">:</span>
                <span class="k">return</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, SuperGradients team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
